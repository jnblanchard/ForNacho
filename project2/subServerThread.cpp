#include "subServerThread.h"extern bool shuttingDown;/*  * Sub server thread * pass in child subscriber process arg[0] * Listen for commands: "end", "sub topic" * If we are not at end of the subscriber read pipe then continue listening for commands. * sub topic prefix means the topic has a new subscriber. ex command = sub topic 5, * thread's subscriber child will be added to the TopicList's subscribers. */void *subServer(void *childInfoP){    ChildInfo &childInfo = *(ChildInfo *)childInfoP;    std::vector<size_t> cursorVector(childInfo.numTopics);    int timeout = 2;        // After a quiet time of 2 seconds we'll give up waiting for sub topic.    bool done = false;    while (done == false && shuttingDown == false) {        std::string command;        ReadResult result = readWithTimeOut(childInfo.fromChild, timeout, command);        if (result == kReadOK) {            if (!command.compare("end")) {                writeStr(childInfo.toChild, "accept");                done = true;            } else if (hasPrefix(command, "sub topic")) {                int topic = std::atoi(command.c_str() + strlen("sub topic"));                int tIndex = topic - 1;                cursorVector[tIndex] = willDequeue(childInfo.topicLists[tIndex]);                childInfo.topics->push_back(topic);                writeStr(childInfo.toChild, "accept");            } else {                std::cerr << "pub server rejecting unexpected command: " << command << std::endl;                writeStr(childInfo.toChild, "reject");            }        } else if (result == kReadTimeout) {            timeout = 0;            done = monitorTopics(childInfo, cursorVector);        } else if (result == kReadEndOfPipe) {            done = true;        }    }    /* Setting the connection type to noConnection puts the select loop back in charge     * of the child's file descriptor.     */    ((ChildInfo *)childInfoP)->connectionType = kNoConnection;    return NULL;}/* Read from the given pipe. If nothing is sent for 'waitSeconds' * then the function times out. If a line is read successfully then * it is appended to 'str'. * * Returns: * kReadTimeout read timed out * kReadOK string returned in 'str' * kReadEndOfPipe End of pipe */ReadResult readWithTimeOut(int fd, int waitSeconds, std::string &str){    ReadResult result = kReadOK;    int numFDs = 0;    fd_set incoming;    char command[1024];    char *inCommand = command;    bool done = false;    size_t nBytes = 0;    struct timeval wait = {        .tv_sec = waitSeconds,        .tv_usec = 0    };    while (nBytes < sizeof(command) && !done) {        FD_ZERO(&incoming);        FD_SET(fd, &incoming);        numFDs = select(fd + 1, &incoming, nullptr, nullptr, &wait);        //fprintf(stderr, "%s: select returned %d\n", __func__, numFDs);        if (numFDs) {            ssize_t n = read(fd, inCommand, 1);            assert(n >= 0);            if (n > 0) {                /* Replace a newline with a NULL byte to terminate the string.                 */                if (*inCommand == '\n') {                    *inCommand = '\0';                    done = true;                    result = kReadOK;                    /* If not a newline then append to the string.                     */                } else {                    inCommand++;                    nBytes++;                }                /* The other end of the pipe closed.                 */            } else {                //fprintf(stderr, "%s: saw an end of pipe\n", __func__);                result = kReadEndOfPipe;                done = true;            }            /* We timed out on the select.             */        } else {            result = kReadTimeout;            done = true;        }    }    str.append(command);    //fprintf(stderr, "%s: returning %d\n", __func__, (int)result);    return result;}bool monitorTopics(ChildInfo child, std::vector<size_t> &iter){    bool gotData = true;    bool abort = false;    /*      * Be greedy and keep grabbing data until we run out.     */    while (gotData) {        gotData = false;        for(std::vector<int>::iterator topic = child.topics->begin(); topic != child.topics->end(); ++topic)        {            std::string text;            int vectIterIndex = *topic-1;            bool result = dequeue(child.topicLists[vectIterIndex], text, iter[vectIterIndex]);            if (result) {                gotData = true;                std::string temp = "topic " + std::to_string(vectIterIndex+1) + " " + text;                fprintf(stderr, "%s (%d): sending %s\n", __func__, child.pubSubID, temp.c_str());                writeStr(child.toChild, temp.c_str());                std::string response;                ReadResult result = readWithTimeOut(child.fromChild, 2, response);                if (result != kReadOK || response != "successful") {                    abort = true;                }            }        }    }        return abort;}